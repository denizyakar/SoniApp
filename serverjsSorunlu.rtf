{\rtf1\ansi\ansicpg1252\cocoartf2868
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 SFPro-Regular;\f1\fnil\fcharset0 AppleColorEmoji;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww14660\viewh10800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs30 \cf0 const express = require('express');\
const http = require('http');\
const path = require('path');\
const \{ Server \} = require('socket.io');\
const mongoose = require('mongoose');\
const cors = require('cors');\
const bcrypt = require('bcryptjs');\
const jwt = require('jsonwebtoken');\
\
// Modeller (Make sure these files are in "models" folder)\
const User = require('./models/User');\
const Message = require('./models/Message');\
//push notifications icin\
const \{ sendPushNotification \} = require('./services/notificationService');\
\
\
const app = express();\
const server = http.createServer(app);\
const port = 10000; // Cloudflare checks this port\
const uri = "burayi_tekrar_doldurmam_gerektigini_bana_hatirlat"\
\
// Settings and Middleware\
app.use(cors()); // required for iOS and external ports\
app.use(express.json()); // to read incoming JSON data\
app.use(express.urlencoded(\{ extended: true \})); \
app.use(express.static(path.join(__dirname, 'public'))); // for browser files\
\
const JWT_SECRET = 'burayi_da_hatirlat_bana_kanki';\
\
// MongoDB Connection\
mongoose.connect(uri)\
  .then(() => console.log('
\f1 \uc0\u9989 
\f0  MongoDB Connected!'))\
  .catch(err => console.error('
\f1 \uc0\u10060 
\f0  MongoDB Error:', err));\
mongoose.connection.setMaxListeners(30);\
// Routes (API ENDPOINTS)\
\
// Push Notifications Token Update Endpoint (add before app.listen)\
app.post('/update-token', async (req, res) => \{\
    try \{\
        // Data coming from phone: username and token\
        const \{ username, token \} = req.body; \
\
        if (!username || !token) \{\
            return res.status(400).json(\{ message: "Missing Information!" \});\
        \}\
\
        // Find the user and update the token\
        await User.findOneAndUpdate(\
            \{ username: username \}, \
            \{ deviceToken: token \}\
        );\
\
        console.log(`
\f1 \uc0\u9989 
\f0  Token updated: $\{username\} -> $\{token.substring(0,5)\}...`);\
        res.status(200).json(\{ message: "Token saved" \});\
\
    \} catch (error) \{\
        console.error("Token saving error:", error);\
        res.status(500).json(\{ message: "Server error" \});\
    \}\
\});\
\
// Delete token after logout - Endpoint\
app.post('/remove-token', async (req, res) => \{\
    try \{\
        const \{ username \} = req.body;\
\
        if (!username) \{\
            return res.status(400).json(\{ message: "Username is missing!" \});\
        \}\
\
        // Find the user and empty the token\
        await User.findOneAndUpdate(\
            \{ username: username \}, \
            \{ deviceToken: "" \} \
        );\
\
        console.log(`
\f1 \uc0\u55357 \u56395 
\f0  Token removed! (Logout): $\{username\}`);\
        res.status(200).json(\{ message: "Token removed" \});\
\
    \} catch (error) \{\
        console.error("Token removal error:", error);\
        res.status(500).json(\{ message: "Server error" \});\
    \}\
\});\
\
// Register\
app.post('/register', async (req, res) => \{\
  try \{\
    const \{ username, password \} = req.body;\
\
    // Does the user already exist?\
    const existingUser = await User.findOne(\{ username \});\
    if (existingUser) \{\
      return res.status(400).json(\{ message: "This username is already taken" \});\
    \}\
\
    // Hash the password - saves as a complex code instead of "123456"\
    const hashedPassword = await bcrypt.hash(password, 10);\
\
    // Create the new user\
    const newUser = new User(\{\
      username,\
      password: hashedPassword\
    \});\
\
    // Save to DB\
    await newUser.save();\
    \
	// for the newly registered users to pop-up in the chatlist \
    io.emit('user_registered', \{ \
        id: newUser._id, \
        username: newUser.username \
    \});\
\
    res.status(201).json(\{ message: "User succesfully registered!" \});\
\
  \} catch (error) \{\
    console.error("Register error(js):", error);\
    res.status(500).json(\{ message: "Server error occurred(js)." \});\
  \}\
  \
\});\
\
// Log In\
app.post('/login', async (req, res) => \{\
  try \{\
    const \{ username, password \} = req.body;\
\
    // Find the user\
    const user = await User.findOne(\{ username \});\
    if (!user) \{\
      return res.status(400).json(\{ message: "User could not be found!" \});\
    \}\
\
    // Check the password\
    const isMatch = await bcrypt.compare(password, user.password);\
    if (!isMatch) \{\
      return res.status(400).json(\{ message: "Incorrect password" \});\
    \}\
\
    // Login succesful! Create Token:\
    const token = jwt.sign(\
      \{ userId: user._id, username: user.username \},\
      JWT_SECRET,\
      \{ expiresIn: '365d' \} // valid for a year\
    );\
\
    // send token and user info to iOS\
    res.json(\{ token, userId: user._id, username: user.username \});\
\
  \} catch (error) \{\
    console.error("Login Error:", error);\
    res.status(500).json(\{ message: "Server error(js)." \});\
  \}\
\});\
\
// Fetch all users\
app.get('/users', async (req, res) => \{\
  try \{\
    // Find all users but don't send the 'password' field (Security!).\
    // .select('-password')` means retrieve everything except the password.\
    const users = await User.find().select('-password');\
    res.json(users);\
  \} catch (error) \{\
    res.status(500).json(\{ message: "Couldn't fetch users(js)." \});\
  \}\
\});\
\
// Fetch old messages\
// fetching from iOS like this: /messages?from=my_Id&to=friend_Id\
// GET /messages?from=xxx&to=yyy\
app.get('/messages', async (req, res) => \{\
  try \{\
    const \{ from, to \} = req.query;\
\
    const messages = await Message.find(\{\
      $or: [\
        \{ senderId: from, receiverId: to \},\
        \{ senderId: to, receiverId: from \},\
      ],\
    \})\
    .sort(\{ date: 1 \})\
    .lean();  // lean() ile plain object d\'f6nd\'fcr (daha h\uc0\u305 zl\u305 )\
\
    // Response'u iOS'un bekledi\uc0\u287 i formata d\'f6n\'fc\u351 t\'fcr\
    const formatted = messages.map(msg => (\{\
      _id:        msg._id.toString(),\
      text:       msg.text,\
      senderId:   msg.senderId,\
      receiverId: msg.receiverId,\
      date:       msg.date ? msg.date.toISOString() : null,\
      senderName: msg.senderName || '',\
      isRead:     msg.isRead || false,\
      readAt:     msg.readAt ? msg.readAt.toISOString() : null,\
      // clientId REST'te gerekmez, sadece socket echo'da laz\uc0\u305 m\
    \}));\
\
    res.json(formatted);\
  \} catch (err) \{\
    console.error('GET /messages error:', err);\
    res.status(500).json(\{ error: 'Server error' \});\
  \}\
\});\
\
\
// Home page for browser\
app.get('/home', (req, res) => \{\
  res.sendFile(path.join(__dirname, 'public', 'home.html'));\
\});\
\
// SOCKET.IO Part (Live Messaging)\
const io = new Server(server, \{\
  cors: \{\
    origin: "https://soni-app.xyz", // Your domain\
    methods: ["GET", "POST"],\
    credentials: true\
  \},\
  // Special settings for Cloudflare\
  transports: ['websocket', 'polling'], // Prioritize WebSocket\
  allowEIO3: true // Compatibility mode\
\});\
\
io.on('connection', (socket) => \{\
  console.log(' A user connected:', socket.id);\
  \
// Messaging event\
  socket.on('chat_message', async (data) => \{\
    console.log("
\f1 \uc0\u55357 \u56552 
\f0  Message received:", data);\
\
    try \{\
      const \{ text, senderId, receiverId, clientId \} = data;\
\
      // G\'f6nderenin username'ini bul (push notification'da da kullan\uc0\u305 lacak)\
      const senderUser = await User.findById(senderId);\
      const senderName = senderUser ? senderUser.username : '';\
\
      // Convert incoming data to MongoDB format \'97 YEN\uc0\u304  ALANLAR EKLEND\u304 \
      const newMessage = new Message(\{\
        text,\
        senderId,\
        receiverId,\
        senderName,                    // \uc0\u8592  YEN\u304 \
        clientId: clientId || null,     // \uc0\u8592  YEN\u304 \
        isRead: false,                 // \uc0\u8592  YEN\u304 \
        readAt: null,                  // \uc0\u8592  YEN\u304 \
      \});\
      \
      // Save to DB(await)\
      const savedMessage = await newMessage.save();\
\
      // Payload \'97 iOS'un bekledi\uc0\u287 i formata d\'f6n\'fc\u351 t\'fcr\
      const payload = \{\
        _id:        savedMessage._id.toString(),\
        text:       savedMessage.text,\
        senderId:   savedMessage.senderId.toString(),\
        receiverId: savedMessage.receiverId.toString(),\
        date:       savedMessage.date.toISOString(),\
        senderName: savedMessage.senderName,\
        isRead:     savedMessage.isRead,\
        readAt:     savedMessage.readAt,\
        clientId:   savedMessage.clientId,\
      \};\
\
      // Emit message \'97 payload olarak g\'f6nder (raw mongoose doc yerine)\
      io.emit('receive_message', payload);\
      \
      // Push Notif Code Start\
      try \{\
          const receiverUser = await User.findById(receiverId);\
\
          if (receiverUser && receiverUser.deviceToken && senderId !== receiverId) \{\
              console.log(`
\f1 \uc0\u55357 \u56960 
\f0  Triggering notification to: $\{receiverUser.username\} person...`);\
              \
              sendPushNotification(\
                  receiverUser.deviceToken,\
                  senderName,\
                  text || "An attachment was sent",\
                  senderId\
              );\
          \}\
      \} catch (notifError) \{\
          console.log("A little error while sending the notification(not crucical):", notifError.message);\
      \}\
      // Push Notif Code End\
\
    \} catch (err) \{\
      console.error("Message saving error:", err);\
    \}\
  \}); // messaging event ends here\
  \
  \
 // Mark as read socket handler:\
socket.on('mark_as_read', async (data) => \{\
  try \{\
    const \{ messageIds, readerId \} = data;\
\
    if (!messageIds || !Array.isArray(messageIds) || messageIds.length === 0) \{\
      return;\
    \}\
\
    const now = new Date();\
\
    // Toplu g\'fcncelleme\
    await Message.updateMany(\
      \{\
        _id: \{ $in: messageIds \},\
        receiverId: readerId,   // G\'fcvenlik: sadece al\uc0\u305 c\u305  okuyabilir\
        isRead: false,\
      \},\
      \{\
        $set: \{\
          isRead: true,\
          readAt: now,\
        \},\
      \}\
    );\
\
    // Orijinal g\'f6nderene "mesajlar\uc0\u305 n okundu" bilgisi g\'f6nder\
    // G\'f6ndereni bulmak i\'e7in ilk mesaj\uc0\u305  kontrol et\
    const firstMessage = await Message.findById(messageIds[0]);\
    if (firstMessage) \{\
      // G\'f6nderene emit et\
      io.emit('read_receipt', \{\
        messageIds: messageIds,\
        readerId: readerId,\
        readAt: now.toISOString(),\
      \});\
      // NOT: io.emit yerine sender'\uc0\u305 n socket'ine \'f6zel emit\
      // daha verimli olur (room-based veya socket map)\
    \}\
\
  \} catch (err) \{\
    console.error('mark_as_read error:', err);\
  \}\
\});\
\
  socket.on('disconnect', () => console.log('
\f1 \uc0\u10060 
\f0  A user left.'));\
\});\
\
\
\
// Start the server\
server.listen(port, '0.0.0.0', () => \{\
  console.log(` System is live on port:10000 and soni-app.xyz!`);\
\});\
\
}